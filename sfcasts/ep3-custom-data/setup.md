# App & Test Setup

Hey friends. Welcome to part three of our API API platform tutorial series. First,
let's get a status check in part one, we got everything we needed for a pretty sweet
API. We talked about JSON LD and open API operations and config, serialization
groups, validation relations filtering in more. In part two, we talked about security
logging in adding security checks to operations, making it so that only some fields
can be read or written by specific users and some pretty serious work related to
custom normalizes for even more control over exactly which field each user sees. In
part three, we take customizations to the next level, like making it possible to
publish in item and run code. When that happens kind of like a custom operation, but
with a restful twist, we'll also add complex ACL around who can publish an item under
different conditions

As well.

Add completely custom fields in completely custom API resources that aren't backed by
doctrine.

Okay.

Let's make things even more interesting where by the, by the end, we'll create custom
filters and even dive deeply into API platforms, input and output D T O system. Whoa,
to be honest, this was one of the hardest tutorials I've written. Not because it was
difficult to figure out how to make these customizations possible, but because we're
getting so deep into API platform, that sometimes there are multiple ways to
accomplish something. We'll find the best paths and learn why. Oh, and a huge thanks
to Kevin Douglas and Antoine ship core API platform developers who helped me a ton to
find, to find these best paths, ready to post the most new data to your brain. You
should, of course code along with me, you can download the course code from this page
after unzipping. It you'll find a start directory with the same code that you see
here, open up the rebate. That MD file for all the exciting setup instructions it's
optional. But in this tutorial, I'm using Docker especial, Docker integration behind
the scenes to get my database setup. One of the last steps in here is going to be to
find a terminal, move into the project and run Symfony serve and dash D to start
these Symfony built in web server@whatdodotzero.zero.one,

Colon 8,000. Let's copy that URL, pop this into a browser and say hello to jeez whiz,
our peer to peer cheese selling site. It doesn't have this tiny front end here. This
has actually built in view JS, but mostly this is just for logging in the vast
majority of the site is an API. Of course, we can see the API documentation by going
to /API. This is the open API documentation that's generated by a swagger. Now, if
you code it along with me in episode one and two, this is the same app, but with some
changes, so make sure you update, you download the latest coat. First. We upgraded
the, all the dependencies in our application. So now using the latest Symfony version
and we're using API platform 2.5.

I also added Foundry to our system, which is a new library that makes it really easy
to create dummy data in your system. So we're using this inside of our data fixtures.
So source data fixtures at fixtures as an easy way to create users and cheese
listings. And we also use this inside of our test suite. You don't need to know too
much about this library, but if you're interested, you can check out our Symfony
doctrine tutorial for more details. Now, before we start, we already have a test
suite in our project with some basic functional tests for the cheese listing resource
and the user resource. And we're going to rely on tests a lot in this tutorial. And
that's in large part because as cool as this, uh, interactive documentation is, and
we will use this, it gets a little tedious to constantly be, uh, hitting, try it out
and filling out all this data manually. And obviously a test system is going to be a
much better way to, uh, to do things. So let's make sure that our test suite is
actually working for, we start so back in the terminal, I'm going to run it. Symfony
run bin /PHP unit. Now a couple of things simply run is just a shortcut for PHP bin
/PHP unit. But if you're using the Symfony Docker integration, then this will execute
that file, but it will inject the Docker environment variables, which give our script
access to our database.

No, the first time you run this, it's actually going to download PHP and in the
background, and once it finishes boom down here, it actually executes my desk and
they are working.

Yeah,

By the way, tests of course run in the test environment. And I do have a little bit
of special configuration the test environment for this project. If you look in config
packages test, so this is directories only loaded in the test. And then dr. Yammel,
you'll see it. I've overridden the, uh, database, uh, configuration to use an
environment variable called database test URL. If you're using the doctrine
integration that I recommend then inside of our Docker compose Diane file, I actually
have two container, two database containers, a may David's container in a
database_test container. So when you use these Symfony by an area it's going to, it's
going to automatically expose the connection parameters to this as database_test_URL.
So I'm basically reading that inside of this file, inside of the main config
packages, doctrine, diagonal I'm reading database, you were out, which is going to
point to the con connection parameters for the other container.

So basically it means that our, when we're developing, we're going to be using this
database container. And when we're running our tests, it's going to be using this
database container. Now, if you're not using the dot the same Docker set up that I
am, you can all, all of course configure this. However you want in the dot ended up
that test file. I already have database tests. You were all defaulting to database
URL. So if you're only setting your database, you were all right now, then your test
environments, just going to use the exact same thing. So feel free to customize how
you, uh, configure your data, your test, your database, and test environment via that
end, that test or via the doctor .yaml in the test environment. And I know with
configuration of Docker, there's a lot going on. So if you have any questions, just
ask us down in the comments. All right. Next, one of the things that we did in the
last course was we created a custom data per sister user data per sister. Let's see
why we did this. Use decoration to make it more powerful and learn how data
persisters are different than some other parts of the system. Like context builders.

[inaudible].
