# App & Test Setup

Hey friends. Yea! It's for part 3 of our API Platform tutorial series. First,
let's do a status check, because we have been busy!

In [part 1](https://symfonycasts.com/screencast/api-platform), we got everything
we needed for a pretty sweet API. We talked about JSON-LD and OpenAPI, operations
and config, serialization groups, validation, relations, IRIs, filtering in more.

In [part 2](https://symfonycasts.com/screencast/api-platform-security), we talked
about security, logging in, adding authorization checks to operations, making it
so that *certain* fields can be read or written only by *specific* users and
some pretty serious work related to custom normalizers for even more control over
*exactly* which fields each user sees.

So what's in part 3? It's time to take customizations to the next level, like
making it possible to publish an item and run code when that happens... kind of
like a custom operation but with a RESTful twist. We'll also add complex security
rules around who can publish an item under different conditions. Then we'll do
everything custom: add completely custom fields, completely custom API resources
that aren't backed by Doctrine, custom filters and we'll even dive deeply into API
Platform', input and output DTO system. Whoa.

To be honest, this was *not* an easy tutorial to write. Not because it was
hard to figure out how to make these customizations - though, some of this *is*
tricky - but because we're getting *so* deep into API Platform, that sometimes
there are *multiple* ways to accomplish something. We'll find the best paths and
learn why. Oh, and a huge thanks to [Kevin Douglas](http://github.com/dunglas)
and [Antoine Bluchet](Antoine Bluchet) - core API platform developers - who helped
me a *ton* to find those best paths.

## Project Setup

So... let's go! To POST the most new data to your brain, you should - of course -
code along with me! Download the course code from this page and, after unzipping
it, you'll find a `start/` directory with the same code that you see here. Pop
open up the `README.md` file for all the details to get this project working on
your machine.

Now, it's *optional*, but in this tutorial, I'm using a special Docker and
symfony binary integration to spin up and configure my database. The details
are in the README and you can learn more about this in our
[Symfony Doctrine Tutorial](https://symfonycasts.com/screencast/symfony-doctrine).

Anyways, one of the steps in the instructions is to find a terminal, move into
the project and run:

```terminal
symfony serve -d
```

to start a dev web server at `https://127.0.0.1:8000`. Copy that URL, find your
browser and say hello to... CheeseWhiz! Our peer-to-peer cheese selling site where
the world can find - and purchase - the cheesy treasures that you forgot were in
your fridge.

Our site *does* have a tiny frontend - this is build in Vue.js - but mostly it's
just for logging in. The vast majority of the site is an API. Go to `/api` to
see the interactive documentation generated by Swagger.

## Updates since Episode 2

Now, if you coded along with me in episodes one and two - you rock - this *is*
the same app, but with some changes... so make sure to download the latest code.
First, we upgraded our dependencies to use Symfony 5.1 and API platform 2.5.

I also added [Foundry](https://github.com/zenstruck/foundry) to our system, which
is a new library that makes it *really* easy to create dummy data in app. We're
using Foundry inside of our data fixtures - so `src/DataFixtures/AppFixtures.php` -
as an easy way to create a bunch of users and cheese listings. We also use this
inside of our test suite. You don't need to know too much about this library, but
if you're interested, check out our
[Symfony Doctrine tutorial](https://symfonycasts.com/screencast/symfony-doctrine/foundry)
for more details.

# Running the Tests

Now, before we start, we *already* have a test suite in our project with some
basic API functional tests for our 2 resources: `CheeseListing` and `User`.
We're going to rely on tests a *lot* in this tutorial... in part because, as cool
as this interactive documentation is - and we *will* use it - it gets a bit
tedious to *constantly* fill use this to test manually. And, of course, having
tests will guarantee our API doesn't break.

So before we start breaking things, let's make sure the tests pass. At your terminal,
run:

```terminal
symfony run bin/phpunit
```

First, `symfony run` is just a a shortcut for executing php. So this mean:

```terminal-silent
php bin/phpunit
```

The difference is that `symfony run` will inject the Docker environment variables,
which will give my script access to the database.

Anyways, the first time you run this, it will download PHPUnit in the background...
and once it finishes... boom! A the bottom it executes our tests and they *are*
working. We have permission to start breaking things!

## The Database Test Config

By the way, our tests - of course - run in the `test` environment... and I *do*
have a little bit of special configuration the `test` environment in this app.
Open up `config/packages/test/` - so, these files are only loaded in the `test`
environment - `doctrine.yaml`.

I've overridden the database config to read an environment variable called
`DATABASE_TEST_URL`. If you're using the Docker Integration that I describe in
the README, then the this environment variable is being *automatically* exposed.
If you look in `docker-compose.yaml`, there are *two* database containers:
`database` and `database_test`. Thanks to this, the symfony binary exposes
`DATABASE_URL` environment variable that points to the first container and a
`DATABASE_TEST_URL` env var that points to the second.

In other words, in the `test` environment, we're using the `database_test`
container and, if you open the main `doctrine.yaml`, in the other environments,
we're reading `DATABASE_URL`, which points to the first container.

That's a *long* way of saying that our tests use a different container than our
`dev` environment. If you're not using this same Docker setup, feel free to customize
this. In `.env.test`, I *am* setting `DATABASE_TEST_URL` to `DATABASE_URL`... which
means that it falls back to using your normal connection config. Feel free to tweak
any of these files and let us know if you have questions.

Next, one of the things that we did in the last course was create a custom data
persister: `UserDataPersister`. Let's see *why* we did this, use decoration to
make it more powerful and learn how data persisters are different than some other
parts of ApiPlatform, like context builders.
